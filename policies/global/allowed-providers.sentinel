# This policy uses the tfconfig/v2 import to restrict providers to those
# in an allowed list.

# It used to only use the providers collection of the tfconfig/v2 import, but
# that did not process resources and data sources from allowed providers
# when no provider block was included in the Terraform configuration. So, it now
# also explicitly allows resources and data sources from allowed providers using
# the resources collection of the tfconfig/v2 import.

# Import common-functions/tfconfig-functions/tfconfig-functions.sentinel
# with alias "config"
# import "tfconfig-functions" as config

# Standard strings import
import "tfconfig/v2" as tfconfig
import "strings"
import "types"

# List of allowed providers
allowed_list = ["aws", "azurerm", "azuread", "terraform", "tfe", "local", "null", "random", "time", "tls"]

##### Functions #####

### find_all_resources ###
# Find all resources of all types using the tfconfig/v2 import.
find_all_resources = func() {
  resources = filter tfconfig.resources as address, r {
  	r.mode is "managed"
  }

  return resources
}

### find_all_datasources ###
# Find all data sources of all types using the tfconfig/v2 import.
find_all_datasources = func() {
  datasources = filter tfconfig.resources as address, d {
  	d.mode is "data"
  }

  return datasources
}

### filter_attribute_not_in_list ###
# Filter a list of items such as providers to those with a specified
# attribute (attr) that is not in a given list of allowed values (allowed).
# The parameter, attr, can only be a top-level attribute of the collection, items.
# Set prtmsg to `true` (without quotes) if you want to print violation messages.
# If you want to disallow null, include "null" in the list (forbidden).
filter_attribute_not_in_list = func(items, attr, allowed, prtmsg) {
  violators = {}
  messages = {}

  # Iterate over items
  for items as index, item {
    val = evaluate_attribute(item, attr) else null
    # Check if the value is null
    if val is null {
      val = "null"
    }
    # Process lists and maps
    if types.type_of(val) in ["list", "map"] {
      message = ""
      # Check each item of list or map
      for val as i, v {
        if v not in allowed {
          # Add the item and a warning message to the violators list
          message = to_string(index) + " has " + to_string(attr) + " with value " +
                    to_string(v) + " that is not in the allowed list: " +
                    to_string(allowed)
        }
        if message is not "" {
          # Add the item and warning message to the violators list
          violators[index] = item
      		messages[index] = message
          if prtmsg {
            print(message)
          }
        } // end message not ""
      } // end for
    } else {
      # Process single item
      if val not in allowed {
        # Add the item and a warning message to the violators list
        message = to_string(index) + " has " + to_string(attr) +
                  " with value " + to_string(val) +
                  " that is not in the allowed list: " +
                  to_string(allowed)
        violators[index] = item
        messages[index] = message
        if prtmsg {
          print(message)
        }
      } // end if single item not matches
    } // end single item
  } // end for items
  return {"items":violators,"messages":messages}
}

### print_violations ###
# Prints violations returned by any of the filter functions defined below.
# This would normally only be called if the filter function had been called
# with prtmsg set to false, which is sometimes done when processing resources
# and their blocks.
# If the result of a filter function is assigned to a map like violatingIRs,
# then you should pass violatingIRs["message"] as the first argument.
# The prefix argument is printed before the message of each resource.
print_violations = func(messages, prefix) {
  for messages as address, message {
    print(prefix, message)
  }
  return true
}

# Get all providers
allProviders = find_all_providers()

# Filter to providers with violations
# Warnings will not be printed for violations since the last parameter is false
violatingProviders = filter_attribute_not_in_list(allProviders,
                     "name", allowed_list, false)

# Print any violations
prohibitedProvidersCount = length(violatingProviders["messages"])
if prohibitedProvidersCount > 0 {
  print_violations(violatingProviders["messages"], "Provider")
}

# Initialize resource and data source counts
prohibitedResourcesCount = 0
prohibitedDataSourcesCount = 0

# Find all resources
allResources = find_all_resources()

# Filter to disallowed resources
prohibitedResources = filter allResources as address, r {
  strings.split(r.type, "_")[0] not in allowed_list
}

# Print violations and increment counts for resources
if length(prohibitedResources) > 0 {
  print("Resources from providers are not allowed unless they are in", allowed_list)
  prohibitedResourcesCount += length(prohibitedResources)
  for prohibitedResources as address, r {
    print("Resource", address, "from provider", strings.split(r.type, "_")[0],
          "is not allowed.")
  } // end for prohibitedResources
} // end if


# Find all data sources
allDataSources = find_all_datasources()

# Filter to disallowed data sources
prohibitedDataSources = filter allDataSources as address, r {
  strings.split(r.type, "_")[0] not in allowed_list
}

# Print violations and increment counts for data sources
if length(prohibitedDataSources) > 0 {
  print("Data sources from providers are not allowed unless they are in", allowed_list)
  prohibitedDataSourcesCount += length(prohibitedDataSources)
  for prohibitedDataSources as address, r {
    print("Data source", address, "from provider", strings.split(r.type, "_")[0],
          "is not allowed.")
  } // end for prohibitedDataSources
} // end if

# Main rule
violations = prohibitedProvidersCount + prohibitedResourcesCount +
             prohibitedDataSourcesCount
main = rule {
  violations is 0
}